#+TITLE: Emacs Configuration
#+OPTIONS: toc:nil

TODO:

+ Customize my mode line [[http://www.gonsie.com/blorg/modeline.html][like this]]
+ Experiment with =ts-ls= via [[https://emacs-lsp.github.io/lsp-mode/page/lsp-typescript/][lsp-mode docs]] (drop tide for =typescript-mode=? will this work with tsx?)

* General
** Fundamental Tweaks

I prefer to remove most of the GUI components at startup.
   
#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (when (boundp 'scroll-bar-mode)
    (scroll-bar-mode -1))
#+end_src

Then, I like to have some more modern looking details.

#+begin_src emacs-lisp
  (setq-default cursor-type 'bar)
  (global-hl-line-mode)
  (global-display-line-numbers-mode)
  (setq column-number-mode t)
  (put 'narrow-to-region 'disabled nil)
#+end_src

Customization can complicate the config files, so it is useful to isolate where Emacs writes customizations.

#+begin_src emacs-lisp
  (setf custom-file "~/.emacs.d/emacs-auto-custom.el")
  (load custom-file t)
#+end_src

** Internals
*** Backup
I want Emacs backup behavior to stay out of my way.

#+begin_src emacs-lisp
  (defvar --backup-directory (concat init-dir "backups"))
  
  (if (not (file-exists-p --backup-directory))
      (make-directory --backup-directory t))
  
  (setq backup-directory-alist `(("." . ,--backup-directory)))
  (setq make-backup-files t               ; backup of a file the first time it is saved.
        backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        delete-by-moving-to-trash t
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
    )
  
  (setq backup-directory-alist `(("." . ,(expand-file-name (concat init-dir "backups")))))
#+end_src

#+begin_src emacs-lisp
  (when (or (eq system-type 'linux)
	    (eq system-type 'gnu/linux))
    (setq create-lockfiles nil))
#+end_src
*** Ubuntu Environment
#+begin_src emacs-lisp
    (when (or (eq system-type 'gnu/linux)
              (eq system-type 'linux))
      (use-package exec-path-from-shell
        :ensure t
        :init (progn
                (exec-path-from-shell-copy-env "SSH_AGENT_PID")
                (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
                (exec-path-from-shell-copy-env "GOPATH")
                (exec-path-from-shell-copy-env "NVM_DIR")
                (exec-path-from-shell-initialize))))
#+end_src

** Editing

By default Emacs does not overwrite a region with new input, unlike virtually every other program in existence.
   
#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

And, then there's the tab issue...

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** Beginning of Line
Change the default =C-a= behavior to jump between the beginning and end of whitespace at the start of the line. I picked this up from [[http://pages.sachachua.com/.emacs.d/Sacha.html#org86eb05b][sachachua's configuration]].
#+begin_src emacs-lisp
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.
  
  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.
  
  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))
  
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
	(forward-line (1- arg))))
  
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
	(move-beginning-of-line 1))))
  
  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
		  'my/smarter-move-beginning-of-line)
#+end_src

*** Transpose Lines
#+begin_src emacs-lisp
  (defun move-line-up ()
    "Swap the current line with the one above it."
    (interactive)
    (transpose-lines 1)
    (previous-line 2))
  
  (defun move-line-down ()
    "Swap the current line with the one below it."
    (interactive)
    (next-line 1)
    (transpose-lines 1)
    (previous-line 1))
#+end_src
** Noise
By default, Emacs makes noise when you do things like try to move past the end of a buffer, which I prefer to disable.

#+begin_src emacs-lisp
  (defun my-bell-function ())
  (setq ring-bell-function 'my-bell-function)
  (setq visible-bell nil)
#+end_src
  
** Configuration Conveniences
  While working on my Emacs configuration, it's helpful to be able to reload quickly. I like to use =C-|= for loading my =init.el= again.

#+begin_src emacs-lisp
  (defun johncoder/reload ()
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (global-set-key (kbd "C-|") 'johncoder/reload)
#+end_src

** Package Sources
Point Emacs at package archives.
#+begin_src emacs-lisp
  (setq package-archives nil)
  
  (defvar melpa '("melpa" . "https://melpa.org/packages/"))
  (defvar org-elpa '("org" . "https://orgmode.org/elpa/"))
  (defvar elpa '("elpa" . "https://elpa.gnu.org/packages/"))
  
  (add-to-list 'package-archives melpa t)
  (add-to-list 'package-archives org-elpa t)
  (add-to-list 'package-archives elpa t)
#+end_src

I'll be relying on =use-package= to set up packages, but it'll need to be fetched before continuing.

#+begin_src emacs-lisp
  (condition-case nil
      (progn
	(require 'use-package))
    (file-error
     (progn
       (package-refresh-contents)
       (package-install 'use-package))))
#+end_src

** Theme
I like to use [[https://nordtheme.com][nord]].
#+begin_src emacs-lisp
  (use-package nord-theme
    :ensure t
    :config (load-theme 'nord t))
#+end_src

But sometimes, a light theme is preferable:

#+begin_src emacs-lisp
  ;; (use-package doom-themes
  ;;   :ensure t
  ;;   :config (load-theme 'doom-one-light t))
  
  ;; (use-package material-theme
  ;;   :ensure t
  ;;   :config
  ;;   (load-theme 'material-light t)
  ;;   (set-cursor-color "#444444"))
  
  ;; TODO(john): do this!
  ;; (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/nord-light-emacs/"))
  ;; (load-theme 'nord-light t)
#+end_src

*** Font
#+begin_src emacs-lisp
  (cond ((and t (member "Office Code Pro" (font-family-list)))
         (set-face-attribute 'default nil :font "Office Code Pro" :height 140))
        ((and nil (member "Alma Mono" (font-family-list)))
         (set-face-attribute 'default nil :family "Alma Mono" :height 140 :width 'ultra-condensed))
        ((and t (member "Consolas" (font-family-list))) (set-face-attribute 'default nil :font "Consolas" :height 140)))
#+end_src

*** Powerline

#+begin_src emacs-lisp
  (setq powerline-image-apple-rgb t)
  (use-package powerline
    :ensure t
    :config (when (eq system-type 'darwin)
	      (setq ns-use-srgb-colorspace 1))
    :init (powerline-default-theme))
#+end_src
*** Center
#+begin_src emacs-lisp
  (use-package centered-window
    :ensure t
    :config (setq cwm-centered-window-width 120))
#+end_src
** Productivity
Transient is a must!

#+begin_src emacs-lisp
  (use-package transient
    :ensure t)
#+end_src

Improve the way I navigate the Emacs interface via counsel, swiper, and projectile.
#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :bind
    (("M-x" . counsel-M-x)
     ("M-y" . counsel-yank-pop)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))

   (use-package swiper
     ;; :pin melpa-stable
     :diminish ivy-mode
     :ensure t
     :bind*
     (("C-s" . swiper)
      ("s-f" . swiper)
      ("C-c C-r" . ivy-resume)
      ("C-x C-f" . counsel-find-file)
      ("C-c h f" . counsel-describe-function)
      ("C-c h v" . counsel-describe-variable)
      ("C-c i u" . counsel-unicode-char)
      ("M-i" . counsel-imenu)
      ("C-c g" . counsel-git)
      ("C-c j" . counsel-git-grep)
      ("C-c k" . counsel-ag)
      ("C-c l" . scounsel-locate))
     :config
     (progn
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
       (ivy-set-actions
	'counsel-find-file
	'(("d" (lambda (x) (delete-file (expand-file-name x)))
	   "delete"
	   )))
       (ivy-set-actions
	'ivy-switch-buffer
	'(("k"
	   (lambda (x)
	     (kill-buffer x)
	     (ivy--reset-state ivy-last))
	   "kill")
	  ("j"
	   ivy--switch-buffer-other-window-action
	   "other window")))))

  (use-package counsel-projectile
    :ensure t
    :config
    (counsel-projectile-mode)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))

  (use-package ivy-hydra :ensure t)
#+end_src

Dumb Jump

#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :config
    (global-set-key (kbd "<f12>") 'dumb-jump-go)
    (global-set-key (kbd "C-=") 'dumb-jump-go)
    (global-set-key (kbd "C-<f12>") 'pop-tag-mark)
    (global-set-key (kbd "C--") 'pop-tag-mark))
  
#+end_src

Ignore files via =rgrep= customization. I want to be able to ignore common files that are littered in various places, such as TypeScript type definition files.

#+begin_src emacs-lisp
  (push "*.d.ts" grep-find-ignored-files)
  (push "*.js.map" grep-find-ignored-files)
#+end_src
** Org
The =org-plus-contrib= package is essential.
#+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib)
  (require 'org-tempo)
#+end_src

Settings

#+begin_src emacs-lisp
  (setq org-agenda-files (list "~/org" "~/org/studies"))
  (setf org-refile-targets '((org-agenda-files :maxlevel . 2))
        org-startup-indented t
        org-agenda-span 'day
        ;; org-log-into-drawer t
        org-clock-idle-time 10
        org-return-follows-link t
        org-special-ctrl-a/e t
        org-pretty-entities t
        org-pretty-entities-include-sub-superscripts t
        org-agenda-skip-scheduled-if-deadline-is-shown t
        org-drill-learn-fraction 0.3
        org-log-done 'time)
#+end_src

Hooks

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'flyspell-mode)
  (add-hook 'org-mode-hook 'org-display-inline-images)
#+end_src

Org keybindings

#+begin_src emacs-lisp
  (define-key global-map "\C-ca" 'org-agenda)
  ;; (define-key global-map "\C-cc" 'org-capture)
  (define-key global-map "\C-cl" 'org-store-link)
#+end_src

Ensure that org behaves more naturally:
 
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
#+end_src

*** Export

#+begin_src emacs-lisp
  (use-package ox-gfm
    :ensure t
    :after '(org))
#+end_src

*** Babel

Look into improving load time by defering the call to =org-babel-do-load-languages=. See [[https://blog.d46.us/advanced-emacs-startup/#org142995b][this]].
    
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((dot . t)
     (ruby . t)
     (python . t)
     (restclient . t)
     (js . t)
     (gnuplot . t)
     (shell . t)
     (plantuml . t)
     (sql . t)))
  (setq org-confirm-babel-evaluate nil)
#+end_src

For making tangled shell files executable:

#+begin_src emacs-lisp
   (defun johncoder/chmod-after-tangle ()
        "Some tangled files are intended to be executed."
        (when (string-suffix-p ".sh" (buffer-file-name))
          (set-file-modes (buffer-file-name) #o755)))
      (add-hook 'org-babel-post-tangle-hook 'johncoder/chmod-after-tangle)
  
#+end_src

*** Capture Templates
I like to keep my org files around, and sometimes I'm forgetful about creating the folder when setting up Emacs on a new machine.

#+begin_src emacs-lisp
  (defvar johncoder--org-directory "~/org")
  
  (if (not (file-exists-p johncoder--org-directory))
      (make-directory johncoder--org-directory t))
#+end_src
  
#+begin_src emacs-lisp
  (setq jrn/org-files/work "~/org/work")
  (setq jrn/org-files/work/inbox "~/org/work/inbox.org")
  (setq jrn/org-files/studies "~/org/studies")
  (setq jrn/org-files/studies/inbox "~/org/studies/inbox.org")
  (setq jrn/org-files/studies/flashcards "~/org/studies/flashcards.org")
  (setq jrn/org-files/personal "~/org/personal")
  (setq jrn/org-files/personal/inbox "~/org/personal/inbox.org")

  (unless (file-exists-p jrn/org-files/work)
    (make-directory jrn/org-files/work t))
  (unless (file-exists-p jrn/org-files/studies)
    (make-directory jrn/org-files/studies t))
  (unless (file-exists-p jrn/org-files/personal)
    (make-directory jrn/org-files/personal t))

  (setq org-capture-templates
        '(;; ---- MISC ----
          ("j" "Append journal entry"
           entry (file+datetree "~/org/journal.org")
           "* %U %^{Title}\n%?")

          ("t" "Micro Blog Entry"
           plain (file+headline "~/org/personal/micro-blog.org" "Micro Blog")
           "** %U by @johncoder %^g\n%?" :prepend t :kill-buffer t)

          ;; ---- WORK ----
          ("a" "Work Agenda Item"
           entry (file+headline jrn/org-files/work/inbox "inbox")
           "* TODO %?\nSCHEDULED: %T\n")

          ("w" "Work Note"
           entry (file+headline jrn/org-files/work/inbox "inbox")
           "* TODO %?\n")

          ("r" "Work Note (reference)"
           entry (file+headline jrn/org-files/work/inbox "inbox")
           "* TODO %?\n%a\n")

          ("f" "Work Flash Card"
           entry (file+headline (concat jrn/org-files/work "/flashcards.org") "all")
           "* Flash Card: %^{Title} :drill:\n%^{Question}\n\n** Answer\nLINK: %a\n\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE")

          ;; ---- STUDIES ----
          ("p" "Studies Agenda Item"
           entry (file+headline jrn/org-files/studies/inbox "inbox")
           "* TODO %?\nSCHEDULED: %T\n")

          ("o" "Studies Note"
           entry (file+headline jrn/org-files/studies/inbox "inbox")
           "* TODO %?\n")

          ("i" "Studies Note (reference)"
           entry (file+headline jrn/org-files/studies/inbox "inbox")
           "* TODO %?\n%a\n")

          ("u" "Studies Flash Card"
           entry (file+headline jrn/org-files/studies/inbox "all")
           "* Flash Card: %^{Title} :drill:\n%^{Question}\n\n** Answer\nLINK: %a\n\n#+BEGIN_QUOTE\n%i\n#+END_QUOTE")

          ;; ---- PERSONAL ----
          ("l" "Personal Agenda Item"
           entry (file+headline jrn/org-files/personal/inbox "inbox")
           "* TODO %?\nSCHEDULED: %T\n")

          ("k" "Personal Note"
           entry (file+headline jrn/org-files/personal/inbox "inbox")
           "* TODO %?\n")

          ("h" "Personal Note (reference)"
           entry (file+headline jrn/org-files/personal/inbox "inbox")
           "* TODO %?\n%a\n")
          ))

  (transient-define-prefix jrn/capture-templates/work ()
    ["Work (Capture Templates)"
     [("a" "Agenda Item" (lambda () (interactive) (org-capture nil "a")))
      ("n" "Note" (lambda () (interactive) (org-capture nil "w")))
      ("r" "Reference" (lambda () (interactive) (org-capture nil "r")))
      ("f" "Flash Card" (lambda () (interactive) (org-capture nil "f")))]])

  (transient-define-prefix jrn/capture-templates/studies ()
    ["Studies (Capture Templates)"
     [("a" "Agenda Item" (lambda () (interactive) (org-capture nil "p")))
      ("n" "Note" (lambda () (interactive) (org-capture nil "o")))
      ("r" "Reference" (lambda () (interactive) (org-capture nil "i")))
      ("f" "Flash Card" (lambda () (interactive) (org-capture nil "u")))]])

  (transient-define-prefix jrn/capture-templates/personal ()
    ["Personal (Capture Templates)"
     [("a" "Agenda Item" (lambda () (interactive) (org-capture nil "l")))
      ("n" "Note" (lambda () (interactive) (org-capture nil "k")))
      ("r" "Reference" (lambda () (interactive) (org-capture nil "h")))]])

  (transient-define-prefix jrn/capture-templates ()
    "Open an organized transient of my org-capture templates."
    ["Capture Templates"
     ("q" "quit" (lambda () (interactive)))]
    ["Directories"
      ("W" "Work" (lambda () (interactive) (dired jrn/org-files/work)))
      ("S" "Studies" (lambda () (interactive) (dired jrn/org-files/studies)))
      ("P" "Personal" (lambda () (interactive) (dired jrn/org-files/personal)))]
    ["Categories"
     ("w" "Work" jrn/capture-templates/work)
     ("s" "Studies" jrn/capture-templates/studies)
     ("p" "Personal" jrn/capture-templates/personal)]
    ["Extras"
     ("i" "org-info" org-info)
     ("c" "org-capture" org-capture)])

  (global-set-key (kbd "C-c c") 'jrn/capture-templates)
#+end_src

*** Jira
Put the configuration stuff in =./work.el=. Consult [[https://github.com/ahungry/org-jira][this page]] for more setup info.

#+begin_src emacs-lisp
  (use-package org-jira
    :ensure t
    :config
    (unless (file-exists-p "~/.org-jira")
      (make-directory "~/.org-jira"))
    (define-key org-jira-entry-mode-map (kbd "C-i pg") 'org-jira-get-projects)
    (define-key org-jira-entry-mode-map (kbd "C-i bg") 'org-jira-get-boards)
    (define-key org-jira-entry-mode-map (kbd "C-i iv") 'org-jira-get-issues-by-board)
    (define-key org-jira-entry-mode-map (kbd "C-i ib") 'org-jira-browse-issue)
    (define-key org-jira-entry-mode-map (kbd "C-i ig") 'org-jira-get-issues)
    (define-key org-jira-entry-mode-map (kbd "C-i ij") 'org-jira-get-issues-from-custom-jql)
    (define-key org-jira-entry-mode-map (kbd "C-i ih") 'org-jira-get-issues-headonly)
    ;;(define-key org-jira-entry-mode-map (kbd "C-c if") 'org-jira-get-issues-from-filter-headonly)
    ;;(define-key org-jira-entry-mode-map (kbd "C-c iF") 'org-jira-get-issues-from-filter)
    (define-key org-jira-entry-mode-map (kbd "C-i iu") 'org-jira-update-issue)
    (define-key org-jira-entry-mode-map (kbd "C-i iw") 'org-jira-progress-issue)
    (define-key org-jira-entry-mode-map (kbd "C-i in") 'org-jira-progress-issue-next)
    (define-key org-jira-entry-mode-map (kbd "C-i ia") 'org-jira-assign-issue)
                                          ;(define-key org-jira-entry-mode-map (kbd "C-c isr") 'org-jira-set-issue-reporter)
    (define-key org-jira-entry-mode-map (kbd "C-i ir") 'org-jira-refresh-issue)
    (define-key org-jira-entry-mode-map (kbd "C-i iR") 'org-jira-refresh-issues-in-buffer)
    (define-key org-jira-entry-mode-map (kbd "C-i ic") 'org-jira-create-issue)
    (define-key org-jira-entry-mode-map (kbd "C-i ik") 'org-jira-copy-current-issue-key)
    (define-key org-jira-entry-mode-map (kbd "C-i sc") 'org-jira-create-subtask)
    (define-key org-jira-entry-mode-map (kbd "C-i sg") 'org-jira-get-subtasks)
    (define-key org-jira-entry-mode-map (kbd "C-i cc") 'org-jira-add-comment)
    (define-key org-jira-entry-mode-map (kbd "C-i cu") 'org-jira-update-comment)
    (define-key org-jira-entry-mode-map (kbd "C-i wu") 'org-jira-update-worklogs-from-org-clocks)
    (define-key org-jira-entry-mode-map (kbd "C-i tj") 'org-jira-todo-to-jira)
    (define-key org-jira-entry-mode-map (kbd "C-i if") 'org-jira-get-issues-by-fixversion))
#+end_src

** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
   :init (setq markdown-command '("pandoc" "--from=markdown" "--to=html5")))
#+end_src
** Reading
#+begin_src emacs-lisp
  (use-package nov
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
  
  (use-package pdf-tools
    :ensure t)
#+end_src
** Writing

Insert a uuid!

#+begin_src emacs-lisp
  (defun uuid ()
    "Generate and insert a uuid.
  From http://ergoemacs.org/emacs/elisp_generate_uuid.html"
    (interactive)
    (let ((myStr (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                                (user-uid)
                                (emacs-pid)
                                (system-name)
                                (user-full-name)
                                (current-time)
                                (emacs-uptime)
                                (garbage-collect)
                                (buffer-string)
                                (random)
                                (recent-keys)))))
        (insert (format "%s-%s-4%s-%s%s-%s"
                        (substring myStr 0 8)
                        (substring myStr 8 12)
                        (substring myStr 13 16)
                        (format "%x" (+ 8 (random 4)))
                        (substring myStr 17 20)
                        (substring myStr 20 32)))))
#+end_src
* Programming
** General
*** Compilation
#+begin_src emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+end_src

Colorful Compilation
#+begin_src emacs-lisp
  (when (require 'ansi-color nil t)
    (defun my-colorize-compilation-buffer ()
      (ansi-color-apply-on-region compilation-filter-start (point-max)))
    (add-hook 'compilation-filter-hook 'my-colorize-compilation-buffer))
#+end_src
*** Parens
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :config (smartparens-global-mode 1))  
#+end_src
*** Highlight Comment Markers

I tend to leave comment markers in code, and it's helpful to highlight them to better catch my attention.
#+begin_src emacs-lisp
  ;; Colorful Markers
  (make-face 'font-lock-fixme-face)
  (make-face 'font-lock-study-face)
  (make-face 'font-lock-important-face)
  (make-face 'font-lock-question-face)
  (make-face 'font-lock-note-face)
  (make-face 'font-lock-see-face)
  (modify-face 'font-lock-fixme-face "#BF616A" nil nil t nil t nil nil)
  (modify-face 'font-lock-study-face "#8FBCBB" nil nil t nil t nil nil)
  (modify-face 'font-lock-important-face "#EBCB8B" nil nil t nil t nil nil)
  (modify-face 'font-lock-question-face "#D08770" nil nil t nil t nil nil)
  (modify-face 'font-lock-see-face "#5E81AC" nil nil t nil t nil nil)
  (modify-face 'font-lock-note-face "#B48EAD" nil nil t nil t nil nil)
  
  (setq fixme-modes '(c++-mode
		      c-mode
		      emacs-lisp-mode
		      js2-mode
		      go-mode
		      python-mode
		      ruby-mode
		      rjsx-mode
		      typescript-mode))
  
  (mapc (lambda (mode)
	  (font-lock-add-keywords
	   mode
	   '(("\\<\\(TODO\\)" 1 'font-lock-fixme-face t)
	     ("\\<\\(STUDY\\)" 1 'font-lock-study-face t)
	     ("\\<\\(IMPORTANT\\)" 1 'font-lock-important-face t)
	     ("\\<\\(QUESTION\\)" 1 'font-lock-question-face t)
	     ("\\<\\(SEE\\)" 1 'font-lock-see-face t)
	     ("\\<\\(NOTE\\)" 1 'font-lock-note-face t))))
	fixme-modes)
#+end_src

*** Rainbow Mode

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :hook (typescript-mode fundamental-mode lisp-mode emacs-lisp-mode web-mode org-mode)
    :delight)
#+end_src
*** Expand Region
This adds the ability to expand selection from the point
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . er/expand-region)
           ("C-+" . er/contract-region)))
#+end_src
*** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+end_src
*** LSP
#+begin_src emacs-lisp
  (defvar +lsp-company-backends 'company-capf)
  (use-package company
    :ensure t
    :init (add-hook 'after-init-hook 'global-company-mode))
  
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024)) ;; 1mb
  (setq lsp-completion-provider :capf)
  
  (use-package lsp-mode
    :ensure t
    :hook (
           (go-mode . lsp)
           (ruby-mode . lsp)
           (typescript-mode . lsp)
           (web-mode . lsp-deferred)
           )
    :commands lsp
    :config
    (setq lsp-log-io nil)
    (setq lsp-restart 'auto-restart)
    (setq lsp-ui-sideline-show-diagnostics t)
    (setq lsp-ui-sideline-show-hover t)
    (setq lsp-ui-sideline-show-code-actions t))
  
  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode)
#+end_src
*** Web Mode
The setup for web-mode with lsp-mode isn't quite right? It worked better out of the box with tide. Here's a [[https://github.com/emacs-typescript/typescript.el/issues/4][thread]] to look at later to try and smooth things over.

#+begin_src emacs-lisp
  (defun setup-web-mode ()
    (interactive)
    ;; (when (string-equal "tsx" (file-name-extension buffer-file-name))
    ;;   (setup-tide-mode))
    (setq indent-tabs-mode nil)
    (setq standard-indent 2))
  
  (flycheck-add-mode 'typescript-tslint 'web-mode)
  
  (use-package web-mode
    :ensure t
    :mode (("\\.html?\\'" . web-mode)
           ("\\.tsx?\\'" . web-mode)
           ("\\.jsx?\\'" . web-mode))
    :hook ((web-mode . setup-web-mode))
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-script-padding 2)
    (setq web-mode-block-padding 2)
    (setq web-mode-style-padding 2)
    (setq web-mode-enable-auto-pairing t)
    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t))
#+end_src
*** Rest Client
#+begin_src emacs-lisp
  (use-package restclient
    :ensure t)
  (use-package ob-restclient
    :ensure t)
#+end_src
*** GraphQL
#+begin_src emacs-lisp
  (use-package graphql-mode
    :ensure t)
  (use-package request
    :ensure t)
#+end_src
** Data/Systems
*** Docker
#+begin_src emacs-lisp
  (use-package docker
    :ensure t)
  (use-package dockerfile-mode
    :ensure t)
  (use-package docker-tramp
    :ensure t)
  (use-package kubel
    :ensure t)
#+end_src
*** Redis
#+begin_src emacs-lisp
  (defun jrn-redis-hook ()
    ;; :hook (redis-cli-mode . jrn-redis-hook))
    (local-set-key (kbd "C-c C-c") 'redis-send-current-line))
  
  (use-package eredis
    :ensure t)
  (use-package redis
    :ensure t)
#+end_src
*** SQL
Indentation

#+begin_src emacs-lisp
  (add-hook 'sql-mode-hook (lambda()
                             (setq indent-tabs-mode nil)))
#+end_src

Truncate lines for interactive mode

#+begin_src emacs-lisp
  (add-hook 'sql-interactive-mode-hook (lambda ()
                                         (toggle-truncate-lines t)))
#+end_src

Specifying Connections

#+begin_src emacs-lisp
  (defvar sql-connection-alist nil)
  
  (defmacro sql-specify-connections (&rest connections)
    "Set the sql-connection-alist from CONNECTIONS.
  Generates respective interactive functions to establish each connection."
    `(progn
       ,@(mapcar (lambda (conn)
                   `(add-to-list 'sql-connection-alist ',conn))
                 connections)
       ,@(mapcar (lambda (conn)
                   (let* ((varname (car conn))
                          (fn-name (intern (format "sql-connect-to-%s" varname)))
                          (buf-name (format "*%s*" varname)))
                     `(defun ,fn-name ,'()
                        (interactive)
                        (sql-connect ',varname ,buf-name))))
                 connections)))
  
#+end_src

#+begin_src emacs-lisp
  (add-hook 'sql-interactive-mode-hook
	    (lambda ()
	      (toggle-truncate-lines t)))
#+end_src

This adds =port= to the list of fields that get prompted when logging into postgres

#+begin_src emacs-lisp
(require 'sql)
(add-to-list 'sql-postgres-login-params '(port))
#+end_src
*** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+end_src
*** Terraform
#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t)
#+end_src
** Git
Use magit and bind status.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (global-set-key (kbd "C-c m") 'magit-status))
#+end_src

** Emacs Lisp
#+begin_src emacs-lisp
  (setq c-default-style "bsd"
	c-basic-offset 4
	tab-width 4
	indent-tabs-mode nil)
#+end_src

#+begin_src emacs-lisp
(use-package slime
  :ensure t)

(use-package clojure-mode
  :ensure cider)

(let ((quicklisp-filename "~/quicklisp/slime-helper.el"))
  (when (file-exists-p quicklisp-filename)
    (load (expand-file-name quicklisp-filename)))
    (setq inferior-lisp-program "/usr/bin/sbcl"))
#+end_src
** Nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t
    :mode "\\.nix\\'")
#+end_src
** C/C++
#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook
	    '(lambda ()
	       (progn (c-set-style "bsd" nil)
		      (setq c-basic-offset 4))))
  
#+end_src
** TypeScript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode "\\.*.ts\\'"
    :hook ((js2-mode . (lambda () (setq js2-basic-offset 2)))
           (typescript-mode . (lambda () (setq indent-tabs-mode nil)))))
  ;; (add-to-list 'auto-mode-alist '("\\/.*\\.[tj]sx\\'" . typescript-mode))
  ;; (add-to-list 'auto-mode-alist '("\\/.*\\.[tj]s\\'" . typescript-mode))
  (setq typescript-indent-level 2)
#+end_src

Tide provides all the nice features for TypeScript in Emacs

#+begin_src emacs-lisp
  (setq js-indent-level 2)
  (setq js2-basic-offset 2)
  (setq company-tooltip-align-annotations t)
  
  ;; (defun setup-tide-mode ()
  ;;   "Setup tide mode."
  ;;   (interactive)
  ;;   (setq tide-server-max-response-length (* 1024 1024 42))
  ;;   (tide-setup)
  ;;   (tide-hl-identifier-mode +1)
  ;;   (eldoc-mode +1)
  ;;   (company-mode +1))
  
  ;; (use-package tide
  ;;   :ensure t
  ;;   :after (typescript-mode company flycheck)
  ;;   :bind (("s-." . tide-fix)
  ;;          ("<f12>" . tide-jump-to-definition)
  ;;          ("S-<f12>" . tide-references))
  ;;   :hook ((typescript-mode . setup-tide-mode)))
#+end_src
** Go
#+begin_src emacs-lisp
  (when (not (eq (getenv "GOPATH") nil))
    (add-to-list 'load-path
                 (concat (getenv "GOPATH")
                         "/src/golang.org/x/lint/misc/emacs"))
    (add-to-list 'load-path
                 (concat (getenv "HOME")
                         "/go/src/golang.org/x/lint/misc/emacs"))
    ;; (require 'golint)
    (use-package golint :defer t))
#+end_src

#+begin_src emacs-lisp
  (defun jrn-go-mode-hook ()
    ;; TODO(john): Check and see if I really want to do this...
    (if (executable-find "goimports")
        (setq gofmt-command "goimports"))

    (add-hook 'before-save-hook 'gofmt-before-save)

    (setq imenu-generic-expression
          '(("type" "^[ \t]*type *\\([^ \t\n\r\f]*[ \t]*\\(struct\\|interface\\)\\)" 1)
            ("func" "^func *\\(.*\\)" 1)))

    (use-package gotest
      :ensure t
      :bind (("C-c , f" . go-test-current-file)
             ("C-c , t" . go-test-current-test)
             ("C-c , p" . go-test-current-project)))

    (local-set-key (kbd "s-.") 'godef-jump)
    (local-set-key (kbd "s->") 'pop-tag-mark)
    (setq tab-width 4
          go-tab-width 4))

  (use-package go-mode
    :ensure t
    :hook (go-mode . jrn-go-mode-hook))

  (use-package flycheck-golangci-lint
    :ensure t
    :hook (go-mode . flycheck-golangci-lint-setup))
  (use-package company-go
    :ensure t
    :hook (go-mode . (lambda ()
                       (set (make-local-variable 'company-backends) '(company-go))
                       (company-mode))))
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t)
#+end_src
** Ruby
#+begin_src emacs-lisp
  (use-package ruby-mode
    :ensure t
    :bind
    ((("C-c C-c" . ruby-send-region))))
  
  (use-package inf-ruby
    :ensure t
    :init
    (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode))
  
  (use-package rake
    :ensure t
    :config
    (eval-after-load 'projectile
      '(setq rake-completion-system projectile-completion-system)))
#+end_src
** Python
#+begin_src emacs-lisp
  (use-package python-info
    :ensure t)
  (setq python-shell-completion-native-enable nil)
#+end_src

* Key Bindings
#+begin_src emacs-lisp
  (global-set-key (kbd "C-<tab>") 'other-window)
  (global-set-key (kbd "C-S-<tab>") 'other-window-prev)
  (global-set-key (kbd "<f5>") 'compile)
  (global-set-key (kbd "s-i") 'compile)
  (global-set-key (kbd "C-<f5>") 'next-error)
  (global-set-key (kbd "C-S-<f5>") 'previous-error)
  (global-set-key (kbd "M-n") 'next-error)
  (global-set-key (kbd "M-p") 'previous-error)
  (global-set-key (kbd "M-S-n") 'next-error)
  (global-set-key (kbd "M-S-p") 'previous-error)
  (global-set-key (kbd "<f1>") 'ff-find-other-file)
  (global-set-key (kbd "<f8>") 'centered-window-mode)
  (global-set-key (kbd "M-F") 'rgrep)
  (global-set-key (kbd "C-`") (lambda ()
                                (interactive)
                                (let ((buf (get-buffer "*ansi-term*"))
                                      (on-ansi-term (string-equal (buffer-name) "*ansi-term*")))
                                  (if on-ansi-term
                                      (progn (other-window -1)
                                             (mode-line-other-buffer))
                                    (unless buf
                                      (ansi-term "/bin/zsh"))
                                    (switch-to-buffer "*ansi-term*")))))
  (global-set-key (kbd "s-k") 'cantrip-run)
  (global-set-key (kbd "C-x a r") 'cantrip-run)
#+end_src

** VS Code Style Bindings
I find myself in VS Code /just/ frequently enough that I want to try
and have some portable muscle memory. These are [[https://duckduckgo.com/?q=vs+code+key+bindings&t=brave&ia=cheatsheet&iax=1][VS Code bindings]] I've
found to be convenient enough for use every day in Emacs:

#+begin_src emacs-lisp
  (global-set-key (kbd "<f12>") 'lsp-find-definition)
  (global-set-key (kbd "s-<f12>") 'lsp-find-type-implementation)
  (global-set-key (kbd "C-S-G") 'magit-status)
  (global-set-key (kbd "M-<down>") 'move-line-down)
  (global-set-key (kbd "M-<up>") 'move-line-up)
  (global-set-key (kbd "s-,") (lambda ()
                                (interactive)
                                (find-file "~/.emacs.d")))
#+end_src

Some macOS bindings for VS Code:

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (global-set-key (kbd "s-w") 'kill-current-buffer)
    (global-set-key (kbd "s-F") 'rgrep)
    (global-set-key (kbd "s-p") 'projectile-find-file)
    (global-set-key (kbd "s-P") 'counsel-M-x))
#+end_src

On Linux and Windows, the hotkeys are more centered around =C-=, which
is inconvenient for a brain trained on Emacs. Unfortunately, this will
take some more time and consideration before setting these up.

#+begin_src emacs-lisp
  (when (not (eq system-type 'darwin))
    ;; (global-set-key (kbd "s-p") 'projectile-find-file)
    ;; (global-set-key (kbd "s-w") 'kill-current-buffer)
    (global-set-key (kbd "C-S-F") 'rgrep)
    (global-set-key (kbd "C-S-P") 'counsel-M-x))
#+end_src
